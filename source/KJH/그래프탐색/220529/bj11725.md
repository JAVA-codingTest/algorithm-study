## 트리의 부모찾기

parents 생각하는 부분이 어려웠다.

```java
import java.util.*;
import java.io.*;
public class Main
{
    static boolean visited[];
    static int N;
    static ArrayList<Integer>[] arr;
   public static void main(String[] args) throws IOException{
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      N = Integer.parseInt(br.readLine());
      arr = new ArrayList[N+1];
      visited = new boolean[N+1];
      for(int i=1; i<N+1; i++){
          arr[i] = new ArrayList();
      }
      
      for(int i=0; i<N-1; i++){
        StringTokenizer st = new StringTokenizer(br.readLine());
        int a = Integer.parseInt(st.nextToken());
        int b = Integer.parseInt(st.nextToken());
        
        arr[a].add(b);
        arr[b].add(a);
      }
      
      int[] parents = new int[N+1];
      
      dfs(parents, 1,0);
      
      for(int j=2; j<=N; j++) System.out.println(parents[j]);
      
   }
   public static void dfs(int[] parents, int start,int parent){
       parents[start] = parent; // 1부터 시작하기 때문에 1은 먼저 루트로 만들어준다
       for(int x: arr[start]){ 
           if(x != parent){
               dfs(parents, x, start); //1을 통해 찾은 다음것인기 때문에 1이 부모가된다 
               
           }
       }
   }
}

```