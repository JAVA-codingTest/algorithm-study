## 나이트의 이동

class 만드는것 참고해서 만들어보았습니다.

```java
import java.io.*;
import java.util.*;

public class Main{
    static int l;
    static int dx[] = {-2,-1,1,2,-2,-1,1,2};
    static int dy[] = {1,2,2,1,-1,-2,-2,-1};
    static Point now, goal;
    public static void main(String[] args)throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());


        ArrayList<Integer> arrlist = new ArrayList<>();

        for(int i=0; i<T; i++){
            l = Integer.parseInt(br.readLine());
            StringTokenizer st = new StringTokenizer(br.readLine());
           now = new Point(Integer.parseInt(st.nextToken()),
            							Integer.parseInt(st.nextToken()), 0);
             st = new StringTokenizer(br.readLine());
            goal = new Point(Integer.parseInt(st.nextToken()),
            							Integer.parseInt(st.nextToken()), 0);

            bfs(now);

        }


    }

    static void bfs(Point p){
        boolean visited[][] = new boolean[l][l];
        Queue<Point> queue = new LinkedList<>();
        visited[p.r][p.c] = true;
        queue.add(p);

        while(!queue.isEmpty()){
            Point tmp = queue.poll();
            int tmpX = tmp.r;
            int tmpY = tmp.c;
            int cnt = tmp.cnt;

            if(tmpX == goal.r && tmpY == goal.c){
                System.out.println(tmp.cnt);
                return;
            }
            for(int i=0; i<8; i++){
                int nx = tmpX + dx[i];
                int ny = tmpY + dy[i];

                if(nx >= 0 && nx < l && ny>= 0 && ny< l && !visited[nx][ny]){
                    queue.add(new Point(nx, ny, cnt+1));
                    visited[nx][ny] = true;
                }
            }
        }
    }

    static class Point{
        int r, c, cnt;

        public Point(int r, int c, int cnt){
            this.r = r;
            this.c = c;
            this.cnt = cnt;
        }
    }
}

```
